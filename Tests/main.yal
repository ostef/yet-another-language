external proc malloc (size : s64) -> *void;
external proc free (ptr : *void);
external proc WriteString (str : string);

const Pi := 3.1415926;
const Tau := Pi * 2.0;

var foo : [1][2][3]*int;

struct Node
{
    var parent : *Node;
    var first_child : *Node;
    var next : *Node;
    var prev : *Node;
}

typedef AllocatorProc = proc (AllocatorOperation, size : s64, ptr : *void, new_size : s64) -> *void;

struct Allocator
{
    var data : *void;
    var procedure : AllocatorProc;
}

struct FooBar
{
    var data : *void;
    var another : *Another;
}

struct Another
{
    var a : int;
    var b : int;
    var c : int;
}

proc AAAlloc (op : AllocatorOperation)
{
    var allocator : Allocator;
    //allocator.foobar = 10;
    allocator.data = null;
    //allocator.procedure = null;

    var ptr := &allocator;
    ptr.data = null;

    var foobar : FooBar;
    foobar.another.a = foobar.another.b;

    var another := *foobar.another;
}

enum AllocatorOperation u8
{
    Alloc;
    Free;
    Resize;
}

proc ToRads (x : float) -> float
{
    return x * (Pi / 180.0);
}

proc ToDegs (x : float) -> float
{
    return x * (180.0 / Pi);
}

proc Min (a : float, b : float) -> float
{
    if a < b
        return a;

    return b;
}

proc Max (a : float, b : float) -> float
{
    if a > b
        return a;

    return b;
}

proc Abs (x : float) -> float
{
    if x < 0.0
        return -x;

    return x;
}

proc Sign (x : float) -> float
{
    if x < 0.0
        return -1.0;

    return 1.0;
}

proc Recursive2 ()
{
    Recursive1 ();
}

proc Recursive1 ()
{
    Recursive2 ();
}

proc IntegerImplicitConversion ()
{
    var a : s64;
    var b : u64;
    var c : u32;

    a = b;  // Should not work
    b = a;  // Should not work
    a = c;  // Should work
    c = a;  // Should not work
    b = c;  // Should work
    c = b;  // Should not work
}

proc Main (args : []string)
{
    var i := 0;
    while i < args.count
    {
        WriteString (args[i]);
        WriteString ("\n");
        i += 1;
    }

}
