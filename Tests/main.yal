const Pi := 3.1415926;
const Tau := Pi * 2.0;

var foo : [1][2][3]*int;

struct Node
{
    var parent : *Node;
    var first_child : *Node;
    var next : *Node;
    var prev : *Node;
}

typedef AllocatorProc = proc (AllocatorOperation, size : s64, ptr : *void, new_size : s64) -> *void;

struct Allocator
{
    var data : *void;
    var procedure : AllocatorProc;
}

struct FooBar
{
    var data : *void;
    var another : *Another;
}

struct Another
{
    var a : int;
    var b : int;
    var c : int;
}

proc AAAlloc (op : AllocatorOperation)
{
    var allocator : Allocator;
    //allocator.foobar = 10;
    allocator.data = null;
    //allocator.procedure = null;

    var ptr := &allocator;
    ptr.data = null;

    var foobar : FooBar;
    foobar.another.a = foobar.another.b;

    var another := *foobar.another;
}

enum AllocatorOperation u8
{
    Alloc;
    Free;
    Resize;
}

proc ToRads (x : float) -> float
{
    return x * (Pi / 180.0);
}

proc ToDegs (x : float) -> float
{
    return x * (180.0 / Pi);
}

proc Min (a : float, b : float) -> float
{
    if a < b
        return a;

    return b;
}

proc Max (a : float, b : float) -> float
{
    if a > b
        return a;

    return b;
}

proc Abs (x : float) -> float
{
    if x < 0.0
        return -x;

    return x;
}

proc Sign (x : float) -> float
{
    if x < 0.0
        return -1.0;

    return 1.0;
}

proc Println (str : string)
{
}

proc Recursive ()
{
    Recursive ();
}

proc Main (args : []string)
{
    var i := 0;
    while i < args.count
    {
        Println (args[i]);
    }

    var procedure := Main;
    procedure (args);

    var value := Min (Max (1.0, 0.0), 10.0);
    var array : [..]int;
    array[0] = 10;
    array.count += 1;
}
