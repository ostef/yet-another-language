external proc malloc (size : s64) -> *void;
external proc free (ptr : *void);
external proc WriteString (str : string);

const Pi := 3.1415926;
const Tau := Pi * 2.0;

var foo : [1][2][3]*int;

struct Node
{
    var parent : *Node;
    var first_child : *Node;
    var next : *Node;
    var prev : *Node;
}

typedef AllocatorProc = proc (AllocatorOperation, size : s64, ptr : *void, new_size : s64) -> *void;

struct Allocator
{
    var data : *void;
    var procedure : AllocatorProc;
}

struct FooBar
{
    var data : *void;
    var another : *Another;
}

struct Another
{
    var a : int;
    var b : int;
    var c : int;
}

proc AAAlloc (op : AllocatorOperation)
{
    var allocator : Allocator;
    //allocator.foobar = 10;
    allocator.data = null;
    //allocator.procedure = null;

    var ptr := &allocator;
    ptr.data = null;

    var foobar : FooBar;
    foobar.another.a = foobar.another.b;

    var another := *foobar.another;
}

enum AllocatorOperation u8
{
    Alloc;
    Free;
    Resize;
}

proc ToRads (x : float) -> float
{
    return x * (Pi / 180.0);
}

proc ToDegs (x : float) -> float
{
    return x * (180.0 / Pi);
}

proc Min (a : float, b : float) -> float
{
    if a < b
        return a;

    return b;
}

proc Max (a : float, b : float) -> float
{
    if a > b
        return a;

    return b;
}

proc Abs (x : float) -> float
{
    if x < 0.0
        return -x;

    return x;
}

proc Sign (x : float) -> float
{
    if x < 0.0
        return -1.0;

    return 1.0;
}

proc Recursive2 ()
{
    Recursive1 ();
}

proc Recursive1 ()
{
    Recursive2 ();
}

proc IntegerImplicitConversion ()
{
    /*{
        var a : s64;
        var b : u64;
        var c : u32;

        a = b;  // Should not work
        b = a;  // Should not work
        a = c;  // Should work
        c = a;  // Should not work
        b = c;  // Should work
        c = b;  // Should not work
    }*/

    /*{
        var a : u32 = 10;
        var b : u32;

        a = -10;
    }*/
}

proc MakeString (count : s64, data : *u8) -> string
{
    var result : string;
    result.data = data;
    result.count = count;

    return result;
}

proc WriteUnsignedNumber (val : u64)
{
    var buffer : [20]u8;

    var len := 0;
    var tmp := val;
    while len == 0 || tmp != 0
    {
        tmp /= 10;
        len += 1;
    }

    var i := 0;
    while i < len
    {
        var digit := cast (u8) val % 10;
        val /= 10;

        buffer[len - i - 1] = cast (u8) ('0' + digit);

        i += 1;
    }

    WriteString (MakeString (len, buffer.data));
}

proc WriteNumber (val : s64)
{
    var unsigned_val : u64;

    if val < 0
    {
        WriteString ("-");
        unsigned_val = cast (u64) -val;
    }
    else
    {
        unsigned_val = cast (u64) val;
    }

    WriteUnsignedNumber (unsigned_val);
}

proc StringLength (str : *u8) -> s64
{
    var i := 0;
    while str[i] != 0
        i += 1;

    return i;
}

proc Main (args : []string)
{
    var i := 0;
    while i < args.count
    {
        WriteString (args[i]);
        WriteString ("\n");

        var len := StringLength (args[i].data);
        WriteUnsignedNumber (cast (u64) len);
        WriteString ("\n");

        i += 1;
    }
}
